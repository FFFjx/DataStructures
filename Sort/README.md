# 排序
## 介绍
- 插入排序：做N-1趟排序，保证从位置0到位置P(P=1,...,N-1)的元素为以已排序状态。每一趟排序都需要往前对比P-1次，因此运行时间是O(N^2)
- 希尔排序：基于一个序列h_t, h_t-1,...,h_1，做t次插入排序，只要求h_1=1。在使用了h_t进行一趟排序后，所有相隔h_t的元素都得到排序，
即a[i]<=a[i+h_t]，则最后经过h_1=1的排序后，所有元素都得到排序。
- 快速排序：首先随机选取数组中的一个数作为枢纽元，然后把数组分为比枢纽元小的数和比枢纽元大的数，递归地对两个子数组调用快速排序，
直到子数组的长度被分割到1则停止。
- 堆排序：使用一个堆储存元素，使用N次deleteMin()获取堆中最小的元素，获取的顺序即为最终排序。每次deleteMin()花费O(logN)时间，因此
算法的总运行时间为O(NlogN)。
## 技术用途
- 任意需要比较元素之间的关系（不一定是数值上的大和小）的实际应用，都需要用到排序。比如某电商网站的某商品按销量排序，比如某导航
分别按距离、预计行驶时间、收费高低给几条路线排序。
## 方法实现
- 插入排序：对数组做N-1趟排序，在第i趟排序中，第i+1个元素与其前一个元素进行对比，若比前一个元素大（以升序排序为例），则跳出循环做
第i+1趟排序；若比前一个元素小，则与前一个元素交换位置并继续与再前一个元素做对比，直到与第1个元素做完对比。
- 希尔排序：基于一个序列h_t, h_t-1,...,h_1，做t次插入排序，每一次排序的对象是那些相隔h_i(1<=i<=t)的元素。
- 快速排序：首先选择数组最左边的数为枢纽元，剩下的最重要的步骤就是如何将数组分割成两部分，其中一部分都小于枢纽元，另一部分大于等于
枢纽元，下面介绍两种分割方式，一种是自己实现的，另一种是在网上找到的，非常巧妙的分割方式。最后的运行时间对比部分设计了一个小对比试验
对比这两种分割方式的优缺点。  
partition(int[] arr, int left, int right)：输入的arr是存放所有待排序数值的数组，left和right分别规定了分割部分两端的下标。
若right-left<=1，则不进行任何操作直接返回。首先引入两个变量i和j，使他们分别等于left和right，i向后搜索，直到找到一个大于等于枢纽元
的数值，j向前搜索，直到找到一个小于枢纽元的数值，若能找到，则两数值交换，循环直到i和j相遇为止，此时的i/j就是分割这一段数据的分割点下标，
将数据分为两部分，递归对这两部分数据调用partition，直到进入一开始的判断语句则停止。  
partitionV3(int[] arr, int left, int right)：输入的arr是存放所有待排序数值的数组，left和right分别规定了分割部分两端的下标。
首先引入两个变量i和j，使他们分别等于left-1和right+1，这两个变量用于存放两个边界，i存放小于枢纽元和等于枢纽元的边界下标，j存放大于
枢纽元和等于枢纽元的边界下标。若left位置的元素小于枢纽元，则交换i+1的位置与left的位置上的元素，然后left++；若大于，
则交换j-1的位置与left的位置上的元素，其余情况left作为下标往后移一位，循环直至left下标与j相遇，最后返回两个边界下标i和j。该算法可以把
原数据段分为小于枢纽元，等于枢纽元，大于枢纽元的三段，并返回两个边界下标，等于枢纽元的部分不需要动，只需要递归处理大于和小于枢纽元的
两个数据段即可。
- 堆排序：首先建一个MAX堆，然后循环把第一个元素与最后一个元素互换，互换后调整第一个元素位置，最后一个元素的位置往前移一位，
相当于做了N次deleteMax，然后总是把Max的放在数组的最后，最终形成一个升序的序列。
## 运行时间对比
### 插入排序
比较了自己写的两个版本的插入排序以及从网上取的性能比较好的一个版本，看看差距如何，首先用一个小数据检查结果的正确性：  
使用数据量为20个随机生成的0-100内的整数来跑程序：  
![IS](https://github.com/FFFjx/DataStructures/blob/main/Sort/pic/InsertionSort1.png)  
首先证明结果无误；然后使用数据量为50000个随机生成的0-100内的整数来比较性能：  
![IS](https://github.com/FFFjx/DataStructures/blob/main/Sort/pic/InsertionSort2.png)  
首先自己写的第一个版本性能远远地被抛开，而第二个版本的有明显提高，但是仍有进步空间，运行时间几乎是最优版本的两倍。
### 希尔排序
使用数据量为50000个的随机生成的0-100内的整数，与插入排序比较性能（其中已包含检查排序结果错误，若有错误会打印出来）：  
![SS](https://github.com/FFFjx/DataStructures/blob/main/Sort/pic/ShellSort.png)    
从程序结果明显可以得到希尔排序的性能确实比插入排序好很多。
### 快速排序
设计了两个实验做对比，一个是数据量为500000个随机生成的0-500000内的整数（重复的数字比较少），另一个是数据量为500000个随机生成的
0-100内的整数（重复的数字非常多），实验结果如下：  
![QS](https://github.com/FFFjx/DataStructures/blob/main/Sort/pic/QuickSort.png)    
quickSort是自己写的，quickSortV2是取网上的，从实验结果可以看出，在重复数字比较少的情况下，quickSort的性能略优，但在重复数字比较多的
情况下，quickSort的性能急速下降，而quickSortV2的性能甚至还上升了，分析其原因，这是因为quickSortV2在partition的时候会把重复的部分
忽略，只需排一次序即不动了，但是quickSort只是简单的区分了小于枢纽元以及大于等于枢纽元的部分，实际上，大于等于枢纽元的部分的排序还是混乱的，
还需要进一步的处理，因此在重复数字增加的情况下，quickSort需要重复处理很多边界值，使得性能下降。
### 堆排序
使用数据量为50000个的随机生成的0-100内的整数，与插入排序比较性能（其中已包含检查排序结果错误，若有错误会打印出来）：  
![HS](https://github.com/FFFjx/DataStructures/blob/main/Sort/pic/HeapSort.png)    
从程序结果明显可以得到堆排序的性能也比插入排序好很多。
 